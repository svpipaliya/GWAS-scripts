### This script performs PC variance analyses, plotting of variance, and plotting of various PCs against once another 
### Needs eigenvalues (.evals) file generated by SMARTPCA to calculate variance and generate screeplots
### Needs mds (eigevecs) file generated by SMARTPCA to plot PC1 against PC2 
### PC1 v PC2 analyses are performed by merging individual 1KG groups into super-populations for clearer visualization

## load libraries for plotting and data manipulation
library(ggplot2)
library(bios2mds)
library(writexl)
library(factoextra)
library(tidyverse)
library(forcats)
library (gridExtra)

## Use the .eigenvals file generated by SMARTPCA - ALL samples
values <- "/Users/ShwetaPipaliya/Documents/PostDoc/projects/gbs_gwas/scripts/PCA/BorghesiGBS.1kg.merge.SNPqc.10.eval"
evalData = read.table(values, header=FALSE)

## Use the .eigenvals file generated by PLINK - ALL samples
plinkevalues <- "/Users/ShwetaPipaliya/Documents/PostDoc/projects/gbs_gwas/data/PLINK_PCA/BorghesiGBS.1kg.plink.pca.10.eigenval"
pl.evalData <- read.table(plinkevalues, header=FALSE)

## Use the .eigenvals file generated by PLINK - EUROPEAN FILTERED SAMPLES
eu.plinkevalues <- "/Users/ShwetaPipaliya/Documents/PostDoc/projects/gbs_gwas/analysis/04_GWAS/EUR.Filt.Borghesi/BorghesiGBS.EUR.1kg.plink.10.pca.eigenval"
eu.pl.evalData <- read.table(eu.plinkevalues, header=FALSE)

## First, calculate the proportion of variance between different PCs using the SMARTPCA eigevalues (.eiganvals) - ALL
## Use algebraic equation of eigenvalues over the total sum multiplied by 100 to give us proportion of variance - ALL
PVE <- evalData$V1 / sum(evalData$V1) # calculates variance in proprotion
PVE_percent <- (evalData$V1 / sum(evalData$V1))* 100 # calculates variance in percentage
round(PVE_percent, 2)
df.PVE <- data.frame(PVE_percent) # takes the PVEs and puts them into a dataframe
write_xlsx(df.PVE, "/Users/ShwetaPipaliya/Desktop/PVE.xlsx") # take df.PVE, convert to excel, and export to file location

## First, calculate the proportion of variance between different PCs using the PLINK eigevalues (.eigenvals) - ALL
## Use algebraic equation of eigenvalues over the total sum multiplied by 100 to give us proportion of variance -ALL
pl.PVE <- pl.evalData$V1 / sum(pl.evalData$V1) # calculates variance in proportion
pl.PVE_percent <- (pl.evalData$V1 / sum(pl.evalData$V1))* 100 # calculates variance in percentage
round(pl.PVE_percent, 2)
df.PVE <- data.frame(pl.PVE_percent) # takes the PVEs and puts them into a dataframe
write_xlsx(df.PVE, "/Users/ShwetaPipaliya/Desktop/pl.PVE_percent.xlsx") # take df.PVE, convert to excel, and export to file location, convert to csv

## First, calculate the proportion of variance between different PCs using the PLINK eigevalues (.eigenvals) - EUR
## Use algebraic equation of eigenvalues over the total sum multiplied by 100 to give us proportion of variance
eu.pl.PVE <- eu.pl.evalData$V1 / sum(eu.pl.evalData$V1) # calculates variance in proportion
eu.pl.PVE_percent <- (eu.pl.evalData$V1 / sum(pl.evalData$V1))* 100 # calculates variance in percentage
round(eu.pl.PVE_percent, 2)
df.PVE <- data.frame(eu.pl.PVE_percent) # takes the PVEs and puts them into a dataframe
write_xlsx(df.PVE, "/Users/ShwetaPipaliya/Desktop/eu.pl.PVE_percent.xlsx") # take df.PVE, convert to excel, and export to file location, convert to csv

## Take the PVEs from the excel file converted to newly formatted CSV and plot the first 10 values in a histogram - SMARTPCA - ALL
PVE_10 <- "/Users/ShwetaPipaliya/Desktop/PC_PVCs.csv" 
PVE_PCs = read.table(PVE_10, header = TRUE, sep=",")
class(PVE_PCs) #figure out data class 

## Take the PVEs from the excel file converted to newly formatted CSV and plot the first 10 values in a histogram - ALL
pl.PVE_10 <- "/Users/ShwetaPipaliya/Desktop/pl.PVE_percent.csv" 
pl.PVE_PCs = read.table(pl.PVE_10, header = TRUE, sep=",")
head(pl.PVE_PCs)
class(pl.PVE_PCs) #figure out data class 

## Take the PVEs from the excel file converted to newly formatted CSV and plot the first 10 values in a histogram - EUR
eu.pl.PVE_10 <- "/Users/ShwetaPipaliya/Desktop/eu.pl.PVE_percent.csv" 
eu.pl.PVE_PCs = read.table(eu.pl.PVE_10, header = TRUE, sep=",")
head(eu.pl.PVE_PCs)
class(eu.pl.PVE_PCs) #figure out data class 

## Create a barplot using ggplot2 with PVE_PCs dataframe - SMARTPCA
## First, reorder the data by x-chars precisely how they needs to appear using mutate function from tidyverse - SMARTPCA
#PVE_PCs_reorder <- PVE_PCs %>%
  #mutate(PCs = fct_relevel(PCs, 
                           #"PC1", "PC2", "PC3", 
                           #"PC4", "PC5", "PC6", 
                           #"PC7", "PC8", "PC9", "PC10")) %>%
  #ggplot( aes(x=PCs, y=PVE)) +
  #geom_bar(stat="identity", position = "dodge", fill = "lightpink4") +
  #xlab("Principle Components") +
  #ylab("Percentange of Variance (%)") +
  #geom_text(aes(label=PVE), position=position_dodge(width=0.5), 
            #size=4, colour="grey27", vjust=-0.04) # This function adds labels on top of the plot
#PVE_PCs_reorder

## Create a barplot using ggplot2 with PVE_PCs dataframe - PLINK -ALL
## First, reorder the data by x-chars precisely how they needs to appear using mutate function from tidyverse - PLINK
pl.PVE_PCs_reorder <- pl.PVE_PCs %>%
  mutate(PCs = fct_relevel(PCs, 
                           "PC1", "PC2", "PC3", 
                           "PC4", "PC5", "PC6", 
                           "PC7", "PC8", "PC9", "PC10")) %>%
  ggplot( aes(x=PCs, y=pl.PVE_percent)) +
  geom_bar(stat="identity", position = "dodge", fill = "turquoise4") +
  xlab("Principle Components") +
  ylab("Percentange of Variance (%)") +
  geom_text(aes(label=pl.PVE_percent), position=position_dodge(width=0.5), 
            size=4, colour="grey27", vjust=-0.04) # This function adds labels on top of the plot
pl.PVE_PCs_reorder

## Create a barplot using ggplot2 with PVE_PCs dataframe - PLINK - EUR
## First, reorder the data by x-chars precisely how they needs to appear using mutate function from tidyverse - PLINK
eu.pl.PVE_PCs_reorder <- eu.pl.PVE_PCs %>%
  mutate(PCs = fct_relevel(PCs, 
                           "PC1", "PC2", "PC3", 
                           "PC4", "PC5", "PC6", 
                           "PC7", "PC8", "PC9", "PC10")) %>%
  ggplot( aes(x=PCs, y=eu.pl.PVE_percent)) +
  geom_bar(stat="identity", position = "dodge", fill = "indianred2") +
  xlab("Principle Components") +
  ylab("Percentange of Variance (%)") +
  geom_text(aes(label=eu.pl.PVE_percent), position=position_dodge(width=0.5), 
            size=4, colour="grey27", vjust=-0.04) # This function adds labels on top of the plot
eu.pl.PVE_PCs_reorder

## Generate a Scree plot from the PVEs - SMARTPCA
PVEplot <- qplot(c(1:10), PVE) + 
  geom_line() + 
  xlab("Principal Component") + 
  ylab("Proportion of Variance") +
  ggtitle("Scree Plot - SMARTPCA") +
  ylim(0, 1) +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
PVEplot 

## Generate a Scree plot from the PVEs - PLINK
pl.PVEplot <- qplot(c(1:10), pl.PVE) + 
  geom_line() + 
  xlab("Principal Component") + 
  ylab("Proportion of Variance") +
  ggtitle("Scree Plot - PLINK") +
  ylim(0, 1) +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
pl.PVEplot 

## Arrange both scree plots into single Figure
grid.arrange(PVEplot, pl.PVEplot , ncol = 2)

## Cumulative PVE plot - SMARTPCA
cumPVE <- qplot(c(1:10), cumsum(PVE)) + 
  geom_line() + 
  xlab("Principal Component") + 
  ylab("Proportion of Variance") + 
  ggtitle("Cumulative Scree Plot - SMARTPCA") +
  ylim(0,1) +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
cumPVE

## Cumulative PVE plot - PLINK
pl.cumPVE <- qplot(c(1:10), cumsum(pl.PVE)) + 
  geom_line() + 
  xlab("Principal Component") + 
  ylab("Proportion of Variance") + 
  ggtitle("Cumulative Scree Plot - PLINK") +
  ylim(0,1) +
  scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
pl.cumPVE

## Arrange Screen and Cumulative plots into single Figure - SMARTPCA
grid.arrange(PVEplot, cumPVE, ncol = 2)

## Arrange both Cumulative plots into single Figure
grid.arrange(cumPVE, pl.cumPVE, ncol = 2)


## Next, perform PC versus PC analyses
## load eigenvector file (BorghesiGBS.1kg.merge.SNPqc.mds) generated by SMARTPCA to generate a dataframe of the eigenvectors
fn = "/Users/ShwetaPipaliya/Desktop/BorghesiGBS.1kg.merge.SNPqc.mds"
evecDat = read.table(fn, header=TRUE)
head(evecDat)

## Produce a PC1 vs PC2 plot from raw evecDataset - Note this is very messy/
## /so we want to merge the individual populations into super-populations (below)
# plot(evecDat$PC1, evecDat$PC2, xlab="PC1", ylab="PC2")

## Read and merge 1KG super-population categories using a re-coded superpopulation table (1KGPop_superpopulation.txt) into the evecData file
popGroups=read.table("/Users/ShwetaPipaliya/Desktop/1KGPop_superpopulation.txt", col.names = c("Pop", "PopGroup"))
head(popGroups)
mergedEvecDat = merge(evecDat, popGroups, by="Pop")
nrow(mergedEvecDat)
nrow(evecDat)

## Can plot the merged dataset (mergedEvecDat) by colour using the standard plot function in R
# mergedEvecDat$PopGroup = as.factor(mergedEvecDat$PopGroup) # this command takes the PopGroup characters as factors so R can colour code them 
# plot(mergedEvecDat$PC1, mergedEvecDat$PC2, col=mergedEvecDat$PopGroup, xlab="PC1", ylab="PC2")
# par(mar=c(1,1,1,1)) # this adjusts the margins
# legend("bottomleft", legend=levels(mergedEvecDat$PopGroup), col=1:length(levels(mergedEvecDat$PopGroup)), pch=21) # pch changes the symbol shape within the legend

## Plotting of the merged dataset performed using ggplot2
require (ggplot2)

## Use the Viridis Colour Package to Visualize PC1 v PC2 and add Title and Labels 
## Visualize PC1 v PC2
g <- ggplot(mergedEvecDat, aes(x=PC1, y=PC2)) + 
  geom_point(aes(col=PopGroup), size=1) +
  scale_colour_viridis_d("1KG Pops")  # change the theme and legend title to "1KG Pops"

theme_update(plot.title = element_text(hjust = 0.5)) # center the plot label
g + ggtitle("PC1 vs PC2") + xlab("PC1 (62.5%)") + ylab("PC2 (20.9%)") 

## Visualize PC2 v PC3
g <- ggplot(mergedEvecDat, aes(x=PC2, y=PC3)) + 
  geom_point(aes(col=PopGroup), size=1) +
  scale_colour_viridis_d("1KG Pops") # change the theme and legend title to "1KG Pops" 

theme_update(plot.title = element_text(hjust = 0.5)) # center the plot label
g + ggtitle("PC2 vs PC3") + xlab("PC2 (20.9%)") + ylab("PC3 (6.25%)") 

## Visualize PC3 v PC4
g <- ggplot(mergedEvecDat, aes(x=PC3, y=PC4)) + 
  geom_point(aes(col=PopGroup), size=1) +
  scale_colour_viridis_d("1KG Pops") # change the theme and legend title to "1KG Pops" 

theme_update(plot.title = element_text(hjust = 0.5)) # center the plot label
g + ggtitle("PC3 vs PC4") + xlab("PC3 (6.3%)") + ylab("PC4 (4.7%)") 

## Visualize PC4 v PC5
g <- ggplot(mergedEvecDat, aes(x=PC4, y=PC5)) + 
  geom_point(aes(col=PopGroup), size=1) +
  scale_colour_viridis_d("1KG Pops") # change the theme and legend title to "1KG Pops" 

theme_update(plot.title = element_text(hjust = 0.5)) # center the plot label
g + ggtitle("PC4 vs PC5") + xlab("PC4 (4.7%)") + ylab("PC5 (1.4%)") 

## Visualize PC5 v PC6
g <- ggplot(mergedEvecDat, aes(x=PC5, y=PC6)) + 
  geom_point(aes(col=PopGroup), size=1) +
  scale_colour_viridis_d("1KG Pops") # change the theme and legend title to "1KG Pops" 

theme_update(plot.title = element_text(hjust = 0.5)) # center the plot label
g + ggtitle("PC5 vs PC6") + xlab("PC5 (1.4%)") + ylab("PC6 (1.1%)") 

## Visualize PC6 v PC7
g <- ggplot(mergedEvecDat, aes(x=PC6, y=PC7)) + 
  geom_point(aes(col=PopGroup), size=1) +
  scale_colour_viridis_d("1KG Pops") # change the theme and legend title to "1KG Pops" 

theme_update(plot.title = element_text(hjust = 0.5)) # center the plot label
g + ggtitle("PC6 vs PC7") + xlab("PC6 (1.1%)") + ylab("PC7 (0.9)") 

## Visualize PC7 v PC8
g <- ggplot(mergedEvecDat, aes(x=PC7, y=PC8)) + 
  geom_point(aes(col=PopGroup), size=1) +
  scale_colour_viridis_d("1KG Pops") # change the theme and legend title to "1KG Pops" 

theme_update(plot.title = element_text(hjust = 0.5)) # center the plot label
g + ggtitle("PC7 vs PC8") + xlab("PC7 (0.9%)") + ylab("PC8 (0.8%)") 

## Visualize PC8 v PC9
g <- ggplot(mergedEvecDat, aes(x=PC8, y=PC9)) + 
  geom_point(aes(col=PopGroup), size=1) +
  scale_colour_viridis_d("1KG Pops") # change the theme and legend title to "1KG Pops" 

theme_update(plot.title = element_text(hjust = 0.5)) # center the plot label
g + ggtitle("PC8 vs PC9") + xlab("PC8 (0.8%") + ylab("PC9 (0.7%)") 

## Visualize PC9 v PC10
g <- ggplot(mergedEvecDat, aes(x=PC9, y=PC10)) + 
  geom_point(aes(col=PopGroup), size=1) +
  scale_colour_viridis_d("1KG Pops") # change the theme and legend title to "1KG Pops" 

theme_update(plot.title = element_text(hjust = 0.5)) # center the plot label
g + ggtitle("PC9 vs PC10") + xlab("PC9 (0.7%)") + ylab("PC10 (0.6%)") 


### Code below is null but various options for plotting and calculating in case it ever comes useful
## Calculate variance from the raw PC values from the mds file and then plot a screenplot using the screeplot function from biosmds package 
#install.packages('bios2mds')
#install.packages('rgl')
#library(bios2mds)

# Convert evecData into PC1-10 dataframe
#df.evecData <- data.frame(evecDat$PC1, evecDat$PC2, evecDat$PC3, evecDat$PC4, evecDat$PC5, evecDat$PC6,evecDat$PC7, evecDat$PC8, evecDat$PC9, evecDat$PC10)

#PC_only = "/Users/ShwetaPipaliya/Desktop/BorghesiGBS.1kg.merge.SNPqc_ID_rm.mds"
#PC_only_table = read.table(PC_only, header=TRUE)

#convert eigenvalues to absolute numbers
#absolute_PC_only_table = abs(PC_only_table)


#library("writexl")
#write_xlsx(absolute_PC_only_table, "/Users/ShwetaPipaliya/Desktop/absolute_PC_only_table.xlsx")

#install.packages("factoextra")
#library(factoextra)
#library(ggplot2)

#df.evecData <- data.frame(evecDat$PC1, evecDat$PC2, evecDat$PC3, evecDat$PC4, evecDat$PC5, evecDat$PC6,evecDat$PC7, evecDat$PC8, evecDat$PC9, evecDat$PC10)
#fviz_eig(df.evecData)

dev.off()